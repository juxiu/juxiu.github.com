<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用requirejs进行模块化开发]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8requirejs%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[requireJs使用requireJs 使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。 1&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： 1 &lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： 1 &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 主模块的写法 上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。下面就来看，怎么写main.js。 如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。 12 // main.js alert(&quot;加载成功！&quot;); 但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 1234 // main.js require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 下面，我们看一个实际的例子。 假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写： 123 require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123; // some code here &#125;); require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块的加载 上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 1234567 require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125; &#125;); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。 1234567 require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;lib/jquery.min&quot;, &quot;underscore&quot;: &quot;lib/underscore.min&quot;, &quot;backbone&quot;: &quot;lib/backbone.min&quot; &#125; &#125;); 另一种则是直接改变基目录（baseUrl）。 12345678 require.config(&#123; baseUrl: &quot;js/lib&quot;, paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125; &#125;); 如果某个模块在另一台主机上，也可以直接指定它的网址，比如： 12345require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot; &#125; &#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 AMD 模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写： 123456789 // math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;); 加载方法如下： 1234 // main.js require([&apos;math&apos;], function (math)&#123; alert(math.add(1,1)); &#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 12345678 define([&apos;myLib&apos;], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 加载非规范模块 理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？回答是可以的。这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。 123456789101112 require.config(&#123; shim: &#123; &apos;underscore&apos;:&#123; exports: &apos;_&apos; &#125;, &apos;backbone&apos;: &#123; deps: [&apos;underscore&apos;, &apos;jquery&apos;], exports: &apos;Backbone&apos; &#125; &#125; &#125;); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。比如，jQuery的插件可以这样定义： 123456 shim: &#123; &apos;jquery.scroll&apos;: &#123; deps: [&apos;jquery&apos;], exports: &apos;jQuery.fn.scroll&apos; &#125; &#125; require.js插件 require.js还提供一系列插件，实现一些特定的功能。domready插件，可以让回调函数在页面DOM结构加载完成后再运行。 123 require([&apos;domready!&apos;], function (doc)&#123; // called once the DOM is ready &#125;); text和image插件，则是允许require.js加载文本和图片文件。 12345678910 define([ &apos;text!review.txt&apos;, &apos;image!cat.jpg&apos; ], function(review,cat)&#123; console.log(review); document.body.appendChild(cat); &#125; ); 类似的插件还有json和mdown，用于加载json文件和markdown文件。 转自阮一峰个人博客：Javascript模块化编程（三）：require.js的用法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生ajaxy及其简单封装]]></title>
    <url>%2F%E5%8E%9F%E7%94%9Fajaxy%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85.html</url>
    <content type="text"><![CDATA[原生ajax配置详解12345678910111213141516171819202122232425262728293031323334353637383940// 原生ajax // 1. 创建ajax对象 if(window.XMLHttpRequest)&#123; // // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 var xhr = new XMLHttpRequest() &#125;else&#123; // IE6, IE5 浏览器执行代码 var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) &#125; // 2.连接服务器 open(方法，地址，异步传输) xhr.open(&apos;get&apos;,&apos;file:///d%3A/markown/index.html&apos;,true); // xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 配置请求头 // setRequestHeader(header,value) 向请求添加 HTTP 头。 // header: 规定头的名称 // value: 规定头的值 //3. 发送请求,如果使用的是post方法，则请求携带数据，在send中配置（仅post请求可用） xhr.send() // 4.接收返回，客户端和服务器端有交互的时候会调用onreadystatechange xhr.onreadystatechange=function()&#123; // xhr.readyState 浏览器和服务器进行到哪一步了。 // 0 --(未初始化) ：还没有调用open方法 // 1 --(载入) ：已调用send方法，正在发送请求 // 2 --(载入完成) ：send方法完成，已收到全部响应内容， // 3. --(正在解析) ：正在解析响应内容。 // 4 --(完成) ：响应内容解析完成，可以在客户端使用 if(xhr.readyState == 4)&#123; if(xhr.status== 200)&#123; // xhr.responseText 获得字符串形式的响应数据。 // xhr.responseXML 获得 XML 形式的响应数据。 console.log(&quot;请求成功，响应内容为&quot; + xhr.responseText); &#125;else&#123; console.log(&quot;请求出错！！！&quot;); &#125; &#125; &#125; 对ajax简单封装12345678910111213141516171819202122232425262728293031function ajax(methods,url,callBack,text) &#123; if(window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 var xhr = new XMLHttpRequest() &#125;else&#123; // IE6, IE5 浏览器执行代码 var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) &#125; // 给methods 一个默认值 var methods = methods|| &apos;get&apos; ; xhr.open(methods,url,true); // 如果是get请求，直接调用send方法发送请求 if (methods== &apos;get&apos;)&#123; xhr.send(); &#125; // 如果是post请求，则可配置请求参数 if (methods==&apos;post&apos;)&#123; xhr.send(text); &#125; xhr.onreadystatechange=function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status== 200)&#123; // 请求成功之后调用回调函数 callBack(xhr.responseText); &#125;else&#123; let error = &apos;错误码&apos; + xhr.status callBack(error); &#125; &#125; &#125;&#125; 调用123ajax(&apos;get&apos;,&apos;file:///d%3A/markown/index.html&apos;,&apos;&apos;,function(result)&#123; console.log(result);&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粗解冒泡排序]]></title>
    <url>%2Fjs%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[编程语言对算法的学习可谓是重中之重，现在回顾一下js中的两种简单算法，冒泡排序和快速排序 冒泡排序，顾名思义，像从水底向上冒的泡泡一样，越往上越大，冒泡排序也是一样。 在数组中，把大的往后排，小的往前排。 第一轮比较 每次比较数组中的两项，如果前一个大，则把前后位置颠倒，再比较颠倒后，大的那一项和其后面紧挨着的那一项比较，依次类推直到最后一项。 经过一轮比较后，数组整体内容没有改变，但顺序改变了，数组中最后一项已经是数组中最大的一项。 然后进行第二轮比较，和前面一样，从第一个开始比较，把比较的两项，大的往后排，第二轮结束后，数组中倒数第二项已经变成最大的。 然后进行第三轮比较，第四轮比较…………数组中有多少项，就比较—arr.length-1 轮。 具体代码如下： var arr=[1,0,2,5,6,3,4,8,9]; // 比较arr.length-1轮 for (var i = 0; i &lt; arr.length-1; i++) { // 外层循环值执行了多少轮，内层循环使比较了多少次 // 第一轮结束后，数组中最后一项肯定是最大的，所以没比较和最后一项比较了 // 所以比较次数是arr.length-1-i; for (var j = 0; j&lt; arr.length-1-i;j++) { // 比较arr的第[i]项和第arr的第arr[i+1]项 if (arr[j]&gt;arr[j+1]) { //如果arr[i]项比arr[i+1]项大 // 如果arr[j]大,把arr[i]用temp存起来 var temp=arr[j]; // 把arr[j+1]赋值给arr[j]; arr[j]=arr[j+1]; // 把存着arr[j]的值得temp赋值给arr[j+1]; arr[j+1]=temp; } } } console.log(arr); 打印结果:[0,1,2,3,4,5,6,8,9]; 如果数组本就是排序好的，如果再执行上述代码，仍然会比较arr.length-1轮 所以性能会下降，怎么判断数组本身是否是排好序的呢？ 如果比较了一轮，数组中没有仍和一项有位置改变，那么久说明数组已经排好序了 既然已经拍好序了，那么下面也就不需要在比较了 12345678910111213141516171819202122232425var num=0;bubblingSort(arr);function bubblingSort()&#123; // 声明一个变量，初始值为true var flag=true; for (var i = 0; i &lt; arr.length-1; i++) &#123; for (var j = 0; j&lt; arr.length-1-i;j++) &#123; if (arr[j]&gt;arr[j+1]) &#123; //如果arr[i]项比arr[i+1]项大 // 当判断条件成立时，给flag赋值为false，说明数组中有位置发生改变 flag=false; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; num++; &#125; &#125; // 如果flag走到这里仍然是true，说明这一轮上面的判断条件没有成立 // 也就是数组中没有发生位置改变，排序已经完成，立即终止外层循环 if (flag==true) &#123; break &#125; &#125; console.log(arr); console.log(num);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活便如此一般]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E4%BE%BF%E5%A6%82%E6%AD%A4%E4%B8%80%E8%88%AC.html</url>
    <content type="text"><![CDATA[来到上海不到两年，毕业也刚过半年而已，却总感觉像是过了很久，很多事情不愿意想，可能也习惯就这样慢慢生活。 我开始变得不像一个正常人，也开始不习惯很多人的价值观和思想认知，但也只能慢慢适应，别无他法。 我总幻想输出一些东西，就算时常写写日记也好，又在事后一次一次觉得没有必要，无话可说，后来想也不想了，以至于现在就想享受一下无忧无虑吃了睡，睡了吃就好，没必要去为那些烦扰的事情多动一下脑子。 渐渐变得所有事都可以无所谓，可能也是一种无声的屈服，麻木而残忍。 我没想过要向什么低头，也不肯承认有什么会强大到令我恐惧，但我确实表现的很可怜，我不知道装下去会怎样，但结局肯定不是那么好，人变化的很快，但总后知后觉。 可能也不只我一个人想过这些，不知道那些人最后是怎么解决这种矛盾的，这些看起来不像问题的问题，最终需要有人站出来解答。 就算总说现实残忍，我们又是怎么样落到被残忍的那一方的？不是应该简单快乐的吗？ 还是我们总在欺骗自己，渴望安定，又渴望冒险，渴望富足，又渴望自由，看起来一直在为了幸福而努力，努力的终点也就是像别人一样活着。 永远都不会满足，在一些大大的道理里面寻求安慰，似乎我们都应该这样，努力一点，为了更好的未来，幸苦一点，一分耕耘一分收获，生活在秩序之下，思想从开始就是被禁锢的，因为我们要遵循传统，什么是传统？比别人幸福的生老病死，结婚生子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速构建一个简单的单页vue应用]]></title>
    <url>%2F%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E9%A1%B5vue%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[技术栈 vue-cli webpack vux，vux-loader less,less-loader vue-jsonp vue-scroller ES6 vue-cli：一个vue脚手架工具，利用vue-cli可以快速构建一个vue项目。 webpack：一个现代 JavaScript 应用程序的模块打包工具。 vux： 一个移动端的UI组件库。 vue-jsonp vue的一个插件，用于送jsonp请求。 vue-scroller vue的一个插件，用于实现下拉刷新和上拉加载。 构建过程： 通过命令行安装vue-cli，webpack 通过命令行工具初始化一个基于webpack的vue项目， vue init webpack 删除默认组件和样式 安装vux，vux-loader，进行vux配置 配置过程 在webpack配置文件 =&gt; build/webpack.config.js中引入vux-loader 将原来的导出配置赋值给 变量webpackConfig(可随意取名，建议语义化) 调用vux-loader中的merge方法 123456const vuxLoader = require(&apos;vux-loader&apos;)const webpackConfig = originalConfig // 原来的 module.exports 代码赋值给变量 webpackConfigmodule.exports = vuxLoader.merge(webpackConfig, &#123; plugins: [&apos;vux-ui&apos;]&#125;) 因为vux样式中用less，所以还需要安装less和less-loader 安装完成后即可在项目中使vux中提供的插件了。 备注： 滚屏效果使用的是 Scroller插件 (可在npm中下载，npm中有使用文档) 发送jsonp请求使用的是 vue-jsonp插件 (可在npm中下载，npm中有使用文档) 实现项： 首屏轮播 横向tab 走马灯新闻轮播 新闻列表 下拉刷新页面 上拉加载更多 遇到的小问题: 组件配合使用时出现样式冲突 解决 : 手动进行样式调整 从接口中获取的数据结构不符合组件数据结构以及数据错误 解决 ：根据页面展示布局和组件默认配置项合理筛选数据 页面载入时默认触发上拉加载 解决：定义变量记录首次加载，当首次加载完成后再次触发上拉加载时执行函数中的内容]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理一下vue-router]]></title>
    <url>%2F%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bvue-router.html</url>
    <content type="text"><![CDATA[什么是vue-router？用通俗一点的话来讲，其实就是一个url和组件之间的映射关系，当我们访问不同的url的时候在页面渲染不同的组件 vue-router怎么用？ vue-router作为一个vue的插件来使用： 首先，必定是要安装vue-router =&gt; npm install vue-router –save 在入口文件中引入vue-router =&gt; import Router from ‘vue-router’ 作为插件注册到vue中 =&gt; vue.use(Router) 然后就可以new Router() 得到一个实例对象，并把该对象添加到Vue实例的router属性，为避免在入口文件中造成大量代码冗余，通常做法是新建一个目录用来存放路由的配置对象 在new Router() 的时候，需要传入一个配置对象，该对象中包含一个routers属性，在这个属性中我们设置url和组件之间的关系。 12345678new Router(&#123; routers:[ &#123; path:&apos;url&apos;, component: componentName &#125; ] &#125;) 相应的，在页面中，或者说在其他组件中，用router-view 来渲染和url绑定的组件 vue-router的两种模式 hash 模式 History 模式 在vue-router中默认使用的是hash模式，在hash模式下，使用hash来模拟一个完成的url，hash即url中’#’和’?’之间的内容，当hash改变时，页面不会重新刷新，从而到达不刷新页面改变视图的目的。 当然由于种种原因，我们还可以使用history模式，用那种模式还是看个人习惯吧，history模式美观，确实是比hash要好一些。 动态路由在有些情况下我们需要把多个url匹配到同意个组件，如果我们为每一个url都配置一个路由，那么僵造成大量的重复代码，这时候我们就需要用到动态路由。 动态路由指的是将多个url绑定到同一个组件，在配置路由的时候 格式：path:’pathName/:name’ —此处的name是不固定的变量 path:’pathName/list1’ path:’pathName/list2’ path:’pathName/list3’ path:’pathName/list4’ 以上url都会匹配到 path:’pathName/:name’ 绑定的组件，并会把list1,list2,list3,list4赋值到name变量 在组件中有一个对象，$route,在组件中我们可以通过this.$route.params来访问当前匹配的变量name。 嵌套路由未完待续………………]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速熟悉vuex]]></title>
    <url>%2F%E5%BF%AB%E9%80%9F%E7%86%9F%E6%82%89vuex.html</url>
    <content type="text"><![CDATA[vuex是什么鬼？ 文档上面对vuex的解释是 “一个专为 Vue.js 应用程序开发的状态管理模式”,恩，看完这句是否对vuex有了一个大概的认识？答案是：”认识你个蛇头”。 好吧，在我的认识里，vuex其实就是将组件中的数据集中起来管理的东西,vue是一个根据数据渲染视图的框架，当组件中的数据变化了，视图相应的产生变化，那这里的数据变化，也可以称作是状态变化，所以官方给的解释是一个 “状态管理模式”。 了解一下vuex的安装和使用 和vue-router差不多，直接用包管理工具安装即可 – npm install vuex / yarn add vuex 在入口文件中引入 vuex ，在注册到Vue实例中 12import Vuex from &apos;Vuex&apos;Vue.use(Vuex) 使用vuex 既然vuex是一个把数据集中起来管理的东西，那么我们将数据集中在哪里？ 怎么访问这些集中起来的数据？ 如果这些数据需要修改计算，那么用何种方式计算这些数据？ 开始使用vuex，vuex用数据仓库(store)来管理被集中起来的数据，我们在使用vuex的时候，首先new一个Vuex.store的实例，为了管理方便，一般我们新建一个目录专门用来存放store仓库，在vuex中需要用到vue，所以首相引入vue，vuex，再通过new方法构建出一个数据仓库的实例。 12345import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);export default new Vuex.store(&#123;参数对象&#125;) 在根组件中引入这个Vuex.store实例，将其注册到Vue实例中 1234567891011121314151617import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import Vuex from &apos;Vuex&apos;import store from &apos;./store&apos; //引入Vuex.store实例Vue.config.productionTip = falseVue.use(Vuex);new Vue(&#123; el: &apos;#app&apos;, router, store, //把Vuex.store的实例给到Vue实例中的store属性 template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;); 在创建实例的时候传入的参数对象中，有一个state属性，在这个属性中用来存放全局的应用数据，组件中的data存放的是局部数据。 在我们把Vuex.store实例注入到Vue实例中的时候，Vue实例对象下就会多出来一个属性：$store,我们在组件内部可以通过this.$store来访问这个Vuex.store实例。通过this.$store.state来访问被存起来的全局数据。 为了满足对数据的各种操作，在Vuex.store实例对象参数中除了state之外还有很多属性： getters 在这个属性中存放着state原始数据的派生数据，类似于组件中的计算属性，当我们在state中取出的原始数据需要早计算之后再使用的时候，可以用getters来对数据进行处理。 getters属性的值是一个对象，对象下存放着计算数据的方法，这些方法接收两个参数 store的state (原始数据) store的getters (计算后数据) Mutation 从外部更改store中数据的唯一方法就是在外部提交一个mutation，当组件在使用数据的过程中，通过用户的操作或其他途径需要对store中的数据进行修改时，不能直接修改，唯一的办法是向store提交一个mutation，store的Mutation属性下检测提交的mutation，将修改数据的工作交由Mutation处理 this.$store.commit(‘事件名’,事件处理函数的参数) 在Vuex.store的实例参数中的Mutation中声明这个事件处理函数，对数据进行处理 Action 在Vuex中除了Mutation还有一个属性可以用来修改数据，和Mutation类似，但又不同，不同之处在于：- Mutation处理之后不会返回任何结果 - Action 处理提交的也是Mutation，不是直接更改状态(数据)，Action可以包含任意异步操作 - Action通过 this.$store.dispatch(&apos;事件名&apos;,参数) - 如果我们希望store修改完数据以后会返回数据给组件，那么使用actions，否则使用mutations]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生ajax]]></title>
    <url>%2F%E5%8E%9F%E7%94%9Fajax.html</url>
    <content type="text"><![CDATA[AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML） ajax能够向服务器请求额外的数据，而不用刷新页面，能够带来更好的用户体验，ajax的核心技术其实就是XMLHttpRequest对象。 那么我们应该如何使用ajax，以及在什么情况下使用ajax? XMLHttpRequest 对象是ajax的基础，所有现代浏览器几乎都支持 XMLHttpRequest 对象，不过在 IE5 和 IE6 使用的是 ActiveXObject对象。 使用： 创建XMLHttpRequest实例 配置请求参数，初始化请求 发送请求 处理请求结果 代码实现： 12345678910111213141516var xhr=new XMLHttpRequest();// 配置请求参数，初始化请求 //1. 请求方式，此处为 get请求方式 //2. 请求地址，此处为 &apos;/user&apos; //3. 是否异步，此处为 truexhr.open(&apos;get&apos;,&apos;/user&apos;,true);// 请求完成时触发的事件xhr.onload=function()&#123; //xhr对象下有很多属性 //responseText:返回的内容，是经过ajax内部处理过的，转成了字符串格式，通过responseText拿到的数据永远是字符串 if(xhr.status==200)&#123; //如果请求成功 &#125;&#125;//发送请求xhr.send(); 创建ajax对象，实际上ajax的兼容问题不大，但也还是有，就像前面所说的，大多数浏览器都是支持ajax对象的，但有些顽皮的浏览器就非要搞特殊，具体的就不点名了，大家都知道，兼容问题也很好解决： 12345if(window.XMLHttpRequest)&#123; var xhr=new XMLHttpRequest()&#125;else&#123; var xhr=new ActiveXObject(&apos;microsoft.XMLHTTP&apos;)&#125; ajax中的open方法，ajax的open方法用于配置请求参数，其有三个参数 第一个参数是请求方式，常用的有get/post 方式 第二个参数是请求地址，即文件在服务器上的位置 第三个参数是个布尔值，表示为是否异步处理 发送请求，ajax的send方法用于向服务端发送请求，send方法有一个参数，格式为字符串，此参数只用于post请求，在使用post请求的时候，会将send中的参数写入到请求正文中。 ajax中的数据获取，当ajax向服务端发送请求后，会等待服务器返回内容，服务端会返回请求内容，这个内容会被存在ajax对象下的responseText属性下，其实ajax有两个属性用来储存服务器返回的数据: responseText :获得字符串形式的响应数据。 responseXML :获得 XML 形式的响应数据。 ajax对象中还有许多其他的属性和事件： redaState： ajax的工作状态，有5个状态码，0、1、2、3、4 分别代表不同的工作状态 onredastatechange：当状态码改变的时候触发的事件 status：服务器状态，http状态码，状态码太多就不一一列举了 1xx 这一类型的状态码，代表请求已被接受，需要继续处理 2xx 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 3xx 这类状态码代表需要客户端采取进一步的操作才能完成请求(重定向) 4xx 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。(客户端错误) 5xx 6xx 服务器错误]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题]]></title>
    <url>%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[同源策略 同源：client 与 server 的协议，域名，端口相同 如果一个源的脚本（页面js）去执行另外一个源的脚本（js），会首先检查被执行的代码和当前执行代码的源是否是相同的，如果不同，则会拒绝执行 不是所有的操作的都会受到同源策略的影响，比如：html中的link，script，img等 受到同源策略影响的：ajax、iframe、window.open、cookie、storage 跨域 因为ajax有同源策略，所以在通过ajax发送请求的时候会有一定的限制 当我们发送的请求是http，那么请求是会被发送出去的，服务器也能接收并处理该请求，同时也能正常返回数据，浏览器也能接收，但是在接收阶段会验证是否同源，如果不同源，拒绝后续处理，如果是https协议，则请求都不会发出去 解决方案 利用html5(XMLHttpRequest2.0)当中的新特性，如果是http协议，那么只需要在服务器返回数据的时候，在header中带上：Access-Control-Allow-Origin，并设置一个值，该值是一个域信息，比如请求者所在的域，当然也可以使用 *，那么客户端在接收到数据以后会比较Access-Control-Allow-Origin的值是否和当前发请求的源一致，如果一致则接收数据，但是该方式有很多限制：浏览器兼容不好，https下有问题 后端代理：在和当前请求的源下写一个后端代码，然后通过同源的后端发送请求，当前ajax请求同源下的后端来实现 JSONP：JSON with Padding 能够发送请求 不受同源策略影响 获取到的数据能够被js执行或使用 JSONP原理，实现 后端输出一个函数调用字符串，并把数据做为该函数调用的参数 前端定义好对应的后端输出调用函数，并处理好相关业务 利用html中的script能够不受同源策略影响发送http请求，加载对应的后端代码（函数）并执行 为了能够使用更加灵活，通常后端接口接收一个回调函数名称（输出的函数调用的名称），前端传入一个需要使用名称即可 注意点：需要和后端约定好需要传输的数据，只能通过queryString传输， JSONP优缺点 优势：不需要借助其他额外的技术 缺点：后端接口的安全和私有性比较低，（可以通过服务器来进行配置的），最大的问题是：只支持get请求，并且只支持queryString传递数据]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post请求]]></title>
    <url>%2Fget%E5%92%8Cpost%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[get和post的区别 get和post都是http协议中的一种请求方式，不同的请求方式有不同的特点，工作模式也不一样 get请求没有请求正文部分，而post有，所以get方式不能使用正文提交数据，但是可以使用queryString的方式来提交，注意：queryString是url的一部分，和请求方式无关，所以不论是什么请求方式都是可以有queryString的，需要再次注意的是，queryString的长度（url的长度）是有限制的，所以如果请求方式是get，那么通过queryString提交的数据的话，注意长度不要超出url的长度限制范围，（范围：2000多个，不同浏览器的url长度限制不一样，标准浏览器一般要再多点） 使用queryString方式传输数据的时候需要对传输的数据进行转码（url编码）-encodeURI() 使用http的正文发送（post），那么是通过send方法把数据添加到正文中，同时还需要设置发送头信息，设置content-type的类型，这个类型必须和后端的解析类型保持一致，当数头信息设置成application/x-www-form-urlencoded的时候，不需要手动进行编码 get方式会缓存页面，需要通过随机数或时间戳解决缓存问题，而post不会缓存所以没有该问题 因为get方式会缓存，同时缓存文件名中有提交的数据，所以get方式传递数据有一定隐私安全上的隐患，所以敏感数据通过post提交 异步同步异步、同步、阻塞、非阻塞异步和同步：被请求人的消息通知机制 异步：当被请求人处理完成事情以后会主动通知（事件通知，回调等方式） 同步：当被请求人处理完成事情以后不会主动通知，需要请求的人主动轮询阻塞和非阻塞：请求人事务处理机制 ajax - 异步非阻塞 未完待续…………]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用vue-cli初始化一个vue项目]]></title>
    <url>%2F%E7%94%A8vue-cli%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAvue%E9%A1%B9%E7%9B%AE.html</url>
    <content type="text"><![CDATA[单文件组件和vue-loader解析打包.vue文件 vue为了能够使我们在项目开发中对组件进行更好的维护，提供了一个单文件组件系统，vue把每一个独立的组件放在一个.vue的文件中，在这个文件中提供基础三个自定义标签： 1. template 2. script 3. style 来放置组件不同的内容块，但是因为浏览器不能够直接去识别该文件类型，所以我们需要通过webpack来进行编译打包，官方提供了一个对 .vue 进行处理的loader：vue-loader ERROR in ./src/Hello.vueModule build failed: Error: Cannot find module ‘vue-template-compiler’ vue实际开发使用 .vue 的单组件系统来实现，但是不能适应实际复杂的需求，我们还需要配置很多的一些东西来和 .vue 进行融合，这个配置很繁琐，所以官方提供了一个工具，帮助我们来构建一个项目开发过程中必须使用的一些内容，这个工具：vue-cli，通过这个工具我们就可以很方便的来创建一个基于vue的项目，我们也把这个工具称为—脚手架 安装npm install vue-cli -g(全局)或yarn global add vue-cli 当我们通过上述方式安装好vue的脚手架以后，我们就可以在命令行中使用一个命令：vue（该命令是没有-cli的） vue的使用vue init init：初始化（创建）基于vue的项目 ：构建模板的名称：常用的是 webpack，其他的可以参考：https://github.com/vuejs-templates ：要构建的项目的名称 vue init webpack hello：基于webpack来构建一个名称为hello的vue项目（项目构建一定要联网！联网！联网！） vue-cli是一个交互式命令行，通过vue命令构建项目会需要我们填写一些项目的信息：Project Name：要创建的项目名称（该命令会生产一个package.json文件，文件中的name选项就是这个ProjectName，默认为当前创建的项目目录名称，也可以自行制定（但是需要符合package.json中name命名规则，不要出现大写字母，空格，下划线，可以使用 - ） Project Description：项目简介，也会出现在package.json文件中,可选 Author：作者，可选 下一步直接回车 Install vue-router：是否安装vue路由组件，做项目的话一定要安装 Use ESLint to lint your code：是否需要使用ESLint模块进行代码检测 Setup unit tests with Karma + Mocha?：是否安装测试（单元测试） Setup e2e tests with Nightwatch?：是否安装端到端的测试 完成上面步骤，over！ 通过vue-cli完成配置以后，下一步需要安装vue所需要的依赖包，项目需要安装的依赖包在vue-cli工具自动生成的package.json文件中有说明：dependencies：项目中实际需要使用到的依赖包devDependencies：项目开发过程中需要使用的一些工具包，不是项目实际线上代码的一部分 运行所需要的安装依赖包安装完成以后，就可以启动项目，运行 yarn run dev / npm run dev：开启一个测试开发环境yarn run build : 构建项目，把项目进行打包，我们可以把项目打包后的文件上传到服务器 如果是首次运行，那么会看到一个欢迎页面，下面我们就可以进行项目开发 项目结构 build目录：构建项目命令所需要使用到的一些脚本文件和配置文件 config目录：在vue-cli中会自动安装一个小型的express搭建的热重载web服务器，config里面就是关于这个服务器的相关配置 dist目录：项目编译构建上线后的存放目录 node_modules目录：项目依赖包存放目录 src目录：项目源代码存放目录 static目录：静态资源存放目录 在项目开发过程中，我们的大部分任务是在src这个目录下完成的 main.js：vue脚手架为我们自动生成的项目中设置的入口文件，在该入口文件中，做了一些项目初始化的工作 引入 Vue 引入必要的组件 创建Vue实例 路由当我们的应用变得复杂了以后，涉及到的页面也会变多，逻辑也会变复杂，原来我们是通过多页面的方式来组织和维护我们的网站，但是这样的用户体验不是太好（因为会刷新或跳转页面），为了解决用户体验问题，最好的方式，数据（页面会发生变化），但是不需要跳转、刷新。 通过ajax异步无刷新获取数据 获取到数据以后通过vue来处理和管理还有渲染页面 什么情况下获取数据渲染页面？传统的处理方式：通过url重新发送请求得到新的数据和页面，获取什么页面数据由url来决定，使用了单页面开发模式的话，就不能再使用页面跳转，但是可以使用url中的hash值的变化来决定获取什么内容渲染什么页面。 所以一个url的hash对应一个视图，那么我们就需要设置hash和视图的关系，我们可以把hash和view做一个对应关系（映射） - 设置hash-view的map（映射）关系 - 监听hash变化 - 当hash值变化的时候，根据map找到对应的组件来渲染视图 vue为我们提供了一个第三方的框架来实现上述的功能:vue-router 上面我们提到的 地址-视图 的映射：路由 vue-routerhttps://router.vuejs.org 安装npm install vue-router / yarn add vue-router]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象的简单用法]]></title>
    <url>%2FPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[要了解一个东西，首先要从，它是什么、用来做什么以及怎么取用它这三个方面来了解。 首先，promise是什么？ 我们来参考一下MDN对它的定义: Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 可以看到，promise是一个对象，用来处理异步操作，那么我们又要了解一下什么是同步异步，以下是我对同步异步的理解: 异步：被请求人的消息通知机制，即当被请求者在接收到请求之后，处理请求，处理完成后是否通知请求者的消息通知机制。 同步：请求者的事务处理机制，即当请求者发出请求后，是否等待请求结果，继续处理接下来的事务。 总结promise是什么： promise是一个构造函数，用来处理javascript中的异步操作。 promise用来做什么？在MDN的定义中已经给出答案，它用来处理异步操作，即维护事件处理的状态，方便我们对异步操作获取更直观的感受，就是在一个事件处理的过程中，监听事件处理的状态成功与否，然后由这些状态决定下一步操作。 MDN中对promise有这样的描述： Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 引用阮一峰ES6中的一句话介绍promise能为我们做什么，以及有什么缺点： 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法 Promise是一个构造函数，用来生成Promise实例： 123456789var promise= new Promise(function(resolve,reject)&#123; //执行一些代码 if(如果异步操作成功)&#123; resolve(value) &#125;else&#123; //异步操作失败 reject(error) &#125;&#125;) Promise对象通过维护三种状态来实现异步操作，这三种状态分别是： pending：初始值，不是成功或失败状态 fulfilled ：成功状态 rejected ：操作失败状态 在以上实例构建过程中：Promise在构建实例的过程总接受一个函数作为参数，这个函数又拥有两个函数作为参数（resolve,reject），分别代表着： resolve函数的作用是将Promise对象的状态从“未完成”变为“成功”状态，在异步操作成功时调用，器参数为异步操作返回出的结果。 reject函数的作用则刚好相反，是将Promise对象的状态从“未完成”状态改变为“失败”状态，在异步操作失败时调用，其参数为异步操作失败返回的错误信息。 Promise中的常用API then作用：Promise对象根据异步操作结果，执行相应的回调函数，接受两个回调函数作为参数，第一个为Promise对象状态改变为resolved时调用，第二个回调函数为Promise对象状态改变为reject时调用，第二个参数是可选的，不是必须的，这两个函数都接受Promise传出的值作为参数。 catch作用：该方法是Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 all作用：该方法用于将多个Promise实例包装成一个新的实例12var promise=Promise.all([p1,p2,p3])//该方法接受一个数组作为参数，数组中p1,p2,p3均为promise实例，只有当数组中的promise对象的状态全部为&quot;成功&quot;状态时，promise的状态才会变为成功状态，并将三个数组中的promise对象返回的结果，按照参数的顺序传递给promise的回调函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css水平居中]]></title>
    <url>%2Fcss%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD.html</url>
    <content type="text"><![CDATA[css居中 行内元素居中 只针对行内元素居中的话，如文字，按钮等inline显示模式的元素，居中方法可给其父元素添加text-align即可，如果块级元素被设置成inline的话，也是适用的，但在收到float影响时会失效。 块级元素居中 定宽块级元素居中如果块级元素的宽度固定可给其设置margin为auto来实现居中，margin：0 auto; 的意思是上下边距为0，左右边距自适应为相同值，完成写法为margin：0 auto 0 auto ; 四个参数分别代表上右下左四个边距。 限制条件，固定宽度，否则块级元素默认占据父元素一整行，此设置失效，对浮动元素无效。 不定宽块级元素居中 包裹在ttable标签中，然后给table标签设置margin： 0 auto 实现居中。 或给元素设置display: table 让后给元素设置margin : 0 auto 实现居中。 让父级浮动，设置display:relative; left:50%; 给子元素设置display:relative; -left:50%;实现居中效果; 1234567891011121314&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;inner&quot;&gt;不定宽居中元素&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrap &#123; float: left; /* 让父元素自适应子元素的宽度 */ position: relative; left: 50%; /*让父元素左边在祖先元素的中线上*/ &#125; .inner &#123; position: relative; left: -50%; /*让居中元素，相对父元素向左移动一半*/ &#125; &lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么判断变量是否是一个数组？]]></title>
    <url>%2F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F.html</url>
    <content type="text"><![CDATA[老生常谈的问题，怎么判断变量是否是一个数组？ typeof操作符js中检测数据类型的一种方式，可轻松检测出常用类型，例如，String，Number，Boolean，Function，Undefind，但在对象和数组之间它分不清除。 12345678910111213141516var a=[];var b=&#123;&#125;;console.log(typeof(a)); //objectconsole.log(typeof(b));//objectconsole.log(typeof(null));//object``` 在js中，Array是由Array构造函数创建的实例，本质上是一个对象，所以用typeof检测数组并不准确。2. instanceof操作符 instanceof操作符用于测试一个对象在其原型链中是否存一个构造函数的prototype属性。Object instanceof constructor object：要检测的对象constructor：某个构造函数 var a=[]console.log(a instanceof Array) //true123456instanceof操作符的问题在于，它假定只有一个全局执行环境，如果网页中包含多个框架那实际上就可能存在两个以上的不同的全局环境，从而存在两个以上的Array构造函数，如果从一个框架传入一个数组到另一个框架，那么传入的数组，与第二个框架中创建的数组就有各自不同的构造函数。3. 对象的constructor操属性对象的constructor属性指向其构造函数 var a=[];console.log(a.constructor === Array); //true123456以上方法在某些条件下课检测数组，但特定情况下会导致结果不准确。## 以下是比较常用的方法：1. js中提供了Array.isArray()的方法，用于判断数组。 var a=[]console.log(a.isArray(a));//true123456789101112131415162. 利用对象的toString方法判断数组每个对象下都有tolocaleString(),toString(),valueOf方法，其中调用数组的toString方法会返回数组中每个值的字符串形式拼接成一个以逗号分隔的字符串。首先分析Object.prototype.toString的工作过程：1. 获取this对象的[[Class]]属性的值2.计算出三个字符串&quot;[object &quot;, 第一步的操作结果Result(1), 以及 &quot;]&quot;连接后的新字符串。3. 返回拼接后的字符串&gt;[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.[[class]]为一个表明该对象类型的内部属性，其值类型为字符串。也就是说，用toString方法可以获取对象的[[class]]属性，而[[class]]属性又表明了该对象的类型。具体操作： var a=[];console.log(Object.prototype.toString.call(a)===’[object Array]’);//true 123456call用于改变toString方法中的this指向。封装成函数为： var a=[];var b={};var c= null;function isArray(arr){ //因为兼容问题所以判断是否支持Array.isArray函数 if(typeof Array.isArray ===’function’){ return Array.isArray(arr) }else{ return Object.prototype.toString.call(a)===’[object Array]’ }} console.log(isArray(a));//trueconsole.log(isArray(b));//falseconsole.log(isArray(c));//false ```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个关于字符串的前端面试题]]></title>
    <url>%2F%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[“abc123 ,def456”，反转字母，其他位置不变。无意间看到个有意思的面试题，忽然来了兴趣想着来做一下。 操作字符串用正则的效率比较高，但第一反应还是用原生来操作。下面说一说思路。 取出字符串中字母部分，拆成数组，翻转 拼接回原先的字符串 123456789101112131415161718192021var a=&quot;abc123 ,def456&quot;;//用split将a拆成数组b ， b=[[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos; &apos;],[&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;]]var b= a.split(&apos;,&apos;).map((item)=&gt;&#123; return item.split(&apos;&apos;); &#125;);var result=[];b.forEach((item)=&gt;&#123; for (var i = 0; i &lt; item.length; i++) &#123; if (!isNaN(Number(item[i]))) &#123; result.push(item.splice(0,i).reverse().concat(item).join(&apos;&apos;)); break &#125; &#125;&#125;)//最终得到的result数组中包含两项，cba123 ,fed456,用&apos;,&apos;进行拼接。得到最终结果。只针对这个或这种类型的字符串，如果存在字母前面有特殊字符，操作会跟麻烦，最后还是推荐用正则处理console.log(result.join(&apos;,&apos;)); 最后给出正则处理方法： 12var result = a.replace(/([a-zA-Z]+)/g,str =&gt; str.split(&apos;&apos;).reverse().join(&apos;&apos;))console.log(result)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用echarts水球图]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8echarts%E6%B0%B4%E7%90%83%E5%9B%BE.html</url>
    <content type="text"><![CDATA[使用echarts水球图官方实例中没有水球图样式，当我们需要用到水球图的时候需要下载echarts-liquidfill.js. 使用 在echarts之后引入 echarts-liquidfill.js 准备一个定宽高的DOM用来挂载水球图 初始化水球图 1var chart = echarts.init(document.getElementById(&quot;dom&quot;)) 设置水球参数,并渲染到DOM元素123456789var option=&#123; series:[ &#123; type:&apos;liquidFill&apos;, data:[0.7,0.5] //两个波纹 &#125; ]&#125;;chart.setOption(option); 配置水球图 单个波的配置 每个水波都是单独配置的，单独的配置会覆盖统一配置。 改变波纹防线颜色 123456789101112131415161718var option=&#123; series:[ &#123; type:&apos;liquidFill&apos;, data:[0.7,&#123; value:&quot;0.5&quot;, direction:&apos;left&apos;, itemStyle:&#123; normal:&#123; color:&quot;red&quot; &#125; &#125; &#125;] &#125; ]&#125;;//第二条波纹变为将变为红色 文字配置 水波中间显示 的文字也是可以配置的，处于水波背景和默认背景上的文字颜色是不同的，当然也可以设置成一样的。 文字配置 1234567891011121314151617181920212223242526272829var option=&#123; series:[ &#123; name:&quot;系列名称&quot;, type:&apos;liquidFill&apos;, data:[0.7,&#123; name:&quot;数据名称&quot;, value:&quot;0.5&quot;, direction:&apos;left&apos;, itemStyle:&#123; normal:&#123; color:&quot;red&quot; &#125; &#125; &#125;], label:&#123; normal:&#123; formatter:&quot;显示文字&quot;, //显示在水球图中间的文字，可以是字符串，可以是占位符，也可以是一个函数。 //如果使用&#123;a&#125;\n&#123;b&#125;\nValue: &#123;c&#125; ，a代表系列名称，b代表数据名称，c代表数据值。 textStyle:&#123; color:&apos;red&apos;, //默认背景下的文字颜色 insideColor:&apos;blue&apos;, //水波背景下的文字颜色 fontsize:40 //字体大小 &#125; &#125; &#125; &#125; ]&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用requireJS]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8requireJS.html</url>
    <content type="text"><![CDATA[什么是require?require是AMD模块化规范的具体实现。 目前，通行的js模块化规范有两种，CommonJS和AMD。 CommonJS和AMD有什么不同呢？ CommonJS主要用于服务端，它的特点是同步加载，在某个模块加载完成后才会加载下一模块，这在服务端没什么问题，读取速度就是硬盘的读写速度，但在浏览器中环境下，加载的模块都存储在服务器上，所以加载时间取决于客户端网速，如果网速不过关可能某个模块需要加载很长时间，那之后的模块则不会加载，这会让浏览器在一段时间内处于假死状态，这显然是不合适的。 因此，适用于浏览器的模块化不能使用同步加载，只能用异步加载。 于是AMD应运而生，AMD(Asynchronous Module Definition)的意思就是异步加载，解释下同步异步。 同步异步是一种被请求者的消息通知机制 同步：被请求者处理请求者请求的事，但不会通知请求者处理结果，需要请求者轮询，或者监听被请求者。 异步：被请求者处理请求者请求的事，当处理结果时，通知请求者处理结果。 阻塞：阻塞当前进程，当前进程不完成，不处理下一个进程。 非阻塞：在当前进程处理过程中，不急于得到结果，继续处理下一个进程。 AMD是异步加载，所有依赖加载模块的语句都放在一个回调函数中，当加载完成后执行。 使用requireJSrequireJS是AMD规范的实现，是客户端实现模块化的工具。AMD之与requireJS就像ECMAscript之与javascript，一个是规范，一个是规范的具体实现。 下载requireJS，放在项目js目录下，即可加载，为避免加载时网页失去响应，建议在网页底部加载，或者写成： 123456789&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;async代表要异步加载，避免网页失去响应，ie不支持这个属性，值支持defer。加载requireJS之后需要加载自己的js文件，一般用一个js文件作为模块化的入口文件，其他引入在入口文件中完成。&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; // mian.js即为入口文件，因为默认加载js文件可省略js后缀。data-main 属性为指定加载主模块，上述加载中主模块为main.js,该文件会第一个被加载。 如果在mian中不依赖其他模块可以直接写js程序，如果需要引用其他模块则必须使用requireJS指定的引用方式。requireJS用require函数加载模块，它接受两个参数，第一个参数为一个数组，指定要加载的模块，第二个参数为一个回调函数，在所有模块加载完成后执行 1234567require([&quot;module&quot;],callback(module)&#123; //do something……&#125;)``` 如果我们有很多js目录，存放不同功能的js 文件，那我们可以用require.config方法来配置模块的加载行为，在文件顶部进行配置。 require.config={ paths:{ “module1”:”module1”, “module2”:”module2”, “module1”:”module3”, }} ```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elementUI计数器组件获取最新值]]></title>
    <url>%2FelementUI%E8%AE%A1%E6%95%B0%E5%99%A8%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E5%80%BC.html</url>
    <content type="text"><![CDATA[elementUI计数器组件change事件参数问题使用计数器的时候，v-model绑定数据，点击加减号改变数据，elementUI文档中提供change事件在数据改变时处理相关业务逻辑，提供一个回调参数，文档说明为”最后变更的值”； change事件被定义为绑定值被改变时触发，由v-model数据双向绑定，当改变input中的值得时候，绑定的数据即被改变，但在change事件内部传入回调参数时打印出的值却不是改变后的值。 如果点的是”+” ,则input中的值比打印出的值大 “1”, 如果点的是减号，则input中的值比打印出的值小”1”,究其原因，最后变更的值，是上一次点击事件完成时改变的值，因此在点击事件发生时能够获取到的值是当前绑定数据变更前的值，即，就算把data中绑定的值传入change事件，得到的仍然是上一次变更的值，此次改变后的数据是获取不到的。 问题：如何知道在数据改变时是增大还是减小？ 方法1：用watch监听data中被计数器绑定的值，当值被改变时，触发watch属性，执行其处理函数，完成相关业务逻辑。 但如果需要被监听的是一个数组中的多个对象，且数据需从后端获取，该怎么办？数据中的值是不确定的，有几条数据也是不知道的，这时用监听肯定是不行的。 12345678910111213141516171819shoppingItems:[ &#123; id : 3333, main_head :&quot;这就是个标题&quot;, middle_picture :&apos;http://iph.href.lu/200x200&apos;, price : 1299.00, sumPrice :1130.00, quantity : &apos;11&apos;, checked: false &#125;,&#123; id : 2222, main_head :&quot;这就是个标题&quot;, middle_picture :&apos;http://iph.href.lu/200x200&apos;, price : 1299.00, sumPrice :1130.00, quantity : &apos;11&apos;, checked: false &#125; ] 被折磨之后找到的解决办法： vue文档对nextTick的定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 12345changeNum(newValue)&#123; this.$nextTick(() =&gt; &#123; &lt;!-- 业务逻辑 --&gt; &#125;) &#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘]]></title>
    <url>%2F%E5%A4%87%E5%BF%98.html</url>
    <content type="text"><![CDATA[webstorm破解 贴图库，使用网络图片 谷歌浏览器主题 博客园登录名和密码 guolintao–glt1131.]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不知所想]]></title>
    <url>%2F%E4%B8%8D%E7%9F%A5%E6%89%80%E6%83%B3.html</url>
    <content type="text"><![CDATA[一直以来想自己搭个博客，，一静下来却又不知道写点什么，以前偶尔还能发表一点感慨，现在则总感觉有心无力，感觉到因但还是要活得像个正常人。勉励一下吧还是，读点书，活动一下脑子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无感]]></title>
    <url>%2F%E6%97%A0%E6%84%9F.html</url>
    <content type="text"><![CDATA[我也不知道常挂在嘴边的一切，对于我来说究竟意味着什么，过往很多年，输的习惯了，慢慢很难生出争强好胜心情，偶尔难免有很强的表现欲，有时觉得一切都刚刚好，有时觉得一切都不是原本该有的样子，拿我这样一个二十多岁的年轻人来举例子，实在很得当，因为所有的迷茫困惑我都有。]]></content>
  </entry>
  <entry>
    <title><![CDATA[或乱于心]]></title>
    <url>%2F%E6%88%96%E4%B9%B1%E4%BA%8E%E5%BF%83.html</url>
    <content type="text"><![CDATA[当四月的天光从窗子透进来的时候，或许应该出去走一走，虽然我并没有那么一个窗。 在言语中依然讨论的是如何对付将要遇到的未来的时候，听起来自然稚嫩，不关心性，只是把生命再细细的梳理一下，仿佛并没有什么事情配得上用成熟二字，深谙世故的时候想的是我与全世界背离，绝不与之苟同;不世故的时候又惺惺作态起来，世道维艰，非顺应大道而不能活。 诚然都说深谙世故而不世故是最好的成熟，然而大彻大悟的人，到底是痛到深处了呢，还是已然极乐了呢，他会不会谁都不服呢？ 说，什么是看透世事？ 我喜欢用清高来麻痹自己，就好像说了一口歪门邪道的道理就以为精神仿佛升华了一个层次似的，一口一个我觉得，我认为，真是要把人逼疯，倘若倒退个许多年，应该能成为另一个孔乙己，在飘雪的凛冬，吃着茴香豆，喝着半温的黄酒。 也不忍心看着自己被指责到那么狼狈，于是自己先反省反省吧！ 常把迷茫挂在嘴边，总是在意识到所谓的前途有多惨淡的时候才认真的为自己找个理由开脱，仿佛只要说了我很迷茫，问题的严肃程度就随之降低了几个层次似的，那一瞬间的满面甘苦，仿佛犯了任何错都值得被原谅一样。 于是偶然间见到了那么一段话，用来阐述迷茫再适合不过___根据大多数人的人生经验，我发现我很迷茫，真实的意思往往是:“又不想好好努力，又想继续混吃混喝，可眼看就要撑不下去了，我该怎么办啊！” 这解释挺实在，没毛病！ 忽略了既定的因素，继而陷入自己设下的圈套，不否认在社会大趋势面前一切虚妄言论都讲遭受毁灭性打击，在归于平静之际，悲伤侵涌如洪水，我亦不再说我要成为谁。 叫醒我的依旧是没关过的闹钟，承载我的还是那辆价值几千万的地铁，似乎应该说些什么来表达郁郁不得志，然而继往常一样，我很荣幸去公司能见到人，也怨恨繁复往至终此浮生。 慢慢的有多理想，认镜明月，远远的仿若近离，又不清明。 可能不一样的是对生活的各种见解，如果彼时经历相差甚远，再娓娓动听也都当做强行装X，不愿造成困扰，无论说起来怎样，高吭一声，然后继续搬自己的砖。 四月应该出去走一走，无论几公里，站在没有遮挡的地方，四十五度仰望天空，看见的绝不是明媚的忧伤，把手伸出去，任由阳光穿掌而过，简单的回眸已然翩翩，轻笑几声，足以惊艳了时光，温暖了岁月。 风起于青萍之末，浪成于微澜之间，好感伤怀，莫将惑乱藏于心。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一只特立独行的猪]]></title>
    <url>%2F%E4%B8%80%E5%8F%AA%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AA.html</url>
    <content type="text"><![CDATA[插队的时候，我喂过猪、也放过牛。假如没有人来管，这两种动物也完全知道该怎样生活。它们会自由自在地闲逛，饥则食渴则饮，春天来临时还要谈谈爱情；这样一来，它们的生活层次很低，完全乏善可陈。人来了以后，给它们的生活做出了安排：每一头牛和每一口猪的生活都有了主题。就它们中的大多数而言，这种生活主题是很悲惨的：前者的主题是干活，后者的主题是长肉。我不认为这有什么可抱怨的，因为我当时的生活也不见得丰富了多少，除了八个样板戏，也没有什么消遣。有极少数的猪和牛，它们的生活另有安排。以猪为例，种猪和母猪除了吃，还有别的事可干。就我所见，它们对这些安排也不大喜欢。种猪的任务是交配，换言之，我们的政策准许它当个花花公子。母猪的任务是生崽儿，但有些母猪却要把猪崽儿吃掉。总的来说，人的安排使猪痛苦不堪。但它们还是接受了：猪总是猪啊。 对生活做种种设置是人特有的品性。不光是设置动物，也设置自己。我们知道，在古希腊有个斯巴达，那里的生活被设置得了无生趣，其目的就是要使男人成为亡命战士，使女人成为生育机器，前者像些斗鸡，后者像些母猪。这两类动物是很特别的，但我以为，它们肯定不喜欢自己的生活。但不喜欢又能怎么样？人也好，动物也罢，都很难改变自己的命运。 以下谈到的一只猪有些与众不同。我喂猪时，它已经有四五岁了，从名分上说，它是肉猪，但长得又黑又瘦，两眼炯炯有光。这家伙像山羊一样敏捷， 一米 高的猪栏一跳就过；它还能跳上猪圈的房顶，这一点又像是猫——所以它总是到处游逛，根本就不在圈里呆着。所有喂过猪的知青都把它当宠儿来对待，它也是我的宠儿——因为它只对知青好，容许他们走到 三米 之内，要是别的人，它早就跑了。它是公的，原本该劁掉。不过你去试试看，哪怕你把劁猪刀藏在身后，它也能嗅出来，朝你瞪大眼睛，噢噢地吼起来。我总是用细米糠熬的粥喂它，等它吃够了以后，才把糠对到野草里喂别的猪。其他猪看了嫉妒，一起嚷起来。这时候整个猪场一片鬼哭狼嚎，但我和它都不在乎。吃饱了以后，它就跳上房顶去晒太阳，或者模仿各种声音。它会学汽车响、拖拉机响，学得都很像；有时整天不见踪影。总而言之，所有喂过猪的知青都喜欢它，喜欢它特立独行的派头儿，还说它活得潇洒。但老乡们就不这么浪漫，他们说，这猪不正经。领导则痛恨它，这一点以后还要谈到。我对它则不止是喜欢­——我尊敬它，常常不顾自己虚长十几岁这一现实，把它叫做“猪兄”。如前所述，这位猪兄会模仿各种声音。我想它也学过人说话，但没有学会——假学会了，我们就可以做倾心之谈。但这不能怪它。人和猪的音色差得太远了。 后来，猪兄学会了汽笛叫，这个本领给它招来了麻烦。我们那里有座糖厂，中午要鸣一次汽笛，让工人换班。我们队下地干活时，听见这次汽笛响就收工回来。我的猪兄每天上午十点钟总要跳到房上学汽笛，地里的人听见它叫就回来——这可比糖厂鸣笛早了一个半小时。坦白地说，这不能全怪猪兄，它毕竟不是锅炉，叫起来和汽笛还有些区别，但老乡们却硬说听不出来。领导上因此开了一个会，把它定成了破坏春耕的坏分子，要对它采取专政手段——会议的精神我已经知道了，但我不为它担忧——因为假如专政是指绳索和杀猪刀的话，那是一点门都没有的。以前的领导也不是没试过，一百人也捉不住它。狗也没用：猪兄跑起来像颗鱼雷，能把狗撞出一丈开外。谁知这回是动了真格的，指导员带了二十几个人，手拿五四式手枪；副指导员带了十几人，手持看青的火枪，分两路在猪场外的空地上兜捕它。这就使我陷入了内心的矛盾：按我和它的交情，我该舞起两把杀猪刀冲出去，和它并肩战斗，但我又觉得这样做太过惊世骇俗——它毕竟是只猪啊；还有一个理由，我不敢对抗领导，我怀疑这才是问题之所在。总之，我在一边看着。猪兄的镇定使我佩服之极：它很冷静地躲在手枪和火枪的连线之内，任凭人喊狗咬，不离那条线。这样，拿手枪的人开火就会把拿火枪的打死，反之亦然；两头同时开火，两头都会被打死。至于它，因为目标小，多半没事。就这样连兜了几个圈子，它找到了一个空子，一头撞出去了；跑得潇洒之极。以后我在甘蔗地里还见过它一次，它长出了獠牙，还认识我，但已不容我走近了。这种冷淡使我痛心，但我也赞成它对心怀叵测的人保持距离。 我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个原故，我一直怀念这只特立独行的猪。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
